<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Parsing In Detail</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="parsing__struct_s.html" title="Parsing structs">
<link rel="next" href="backtracking.html" title="Backtracking">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="parsing__struct_s.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="backtracking.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.parsing_in_detail"></a><a class="link" href="parsing_in_detail.html" title="Parsing In Detail">Parsing
      In Detail</a>
</h3></div></div></div>
<p>
        Now that you've seen some examples, let's see how parsing works in a bit
        more detail. Consider this example.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">int_pair</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span><span class="special">;</span>         <span class="comment">// Attribute: tuple&lt;int, int&gt;</span>
<span class="keyword">auto</span> <span class="identifier">int_pairs_plus</span> <span class="special">=</span> <span class="special">+</span><span class="identifier">int_pair</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span><span class="special">;</span>  <span class="comment">// Attribute: tuple&lt;std::vector&lt;tuple&lt;int, int&gt;&gt;, int&gt;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">int_pairs_plus</span></code> must match
        a pair of <code class="computeroutput"><span class="keyword">int</span></code>s (using <code class="computeroutput"><span class="identifier">int_pair</span></code>) one or more times, and then must
        match an additional <code class="computeroutput"><span class="keyword">int</span></code>. In
        other words, it matches any odd number (greater than 1) of <code class="computeroutput"><span class="keyword">int</span></code>s in the input. Let's look at how this
        parse proceeds.
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"1 2 3"</span><span class="special">,</span> <span class="identifier">int_pairs_plus</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<p>
        At the beginning of the parse, the top level parser uses its first subparser
        (if any) to start parsing. So, <code class="computeroutput"><span class="identifier">int_pairs_plus</span></code>,
        being a sequence parser, would pass control to its first parser <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>.
        Then <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>
        would use <code class="computeroutput"><span class="identifier">int_pair</span></code> to do
        its parsing, which would in turn use <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code>.
        This creates a stack of parsers, each one using a particular subparser.
      </p>
<p>
        Step 1) The input is <code class="computeroutput"><span class="string">"1 2 3"</span></code>,
        and the stack of active parsers is <code class="computeroutput"><span class="identifier">int_pairs_plus</span></code>
        -&gt; <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>
        -&gt; <code class="computeroutput"><span class="identifier">int_pair</span></code> -&gt; <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code>.
        (Read "-&gt;" as "uses".) This parses <code class="computeroutput"><span class="string">"1"</span></code>,
        and the whitespace after is skipped by <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span></code>. Control
        passes to the second <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code> parser in <code class="computeroutput"><span class="identifier">int_pair</span></code>.
      </p>
<p>
        Step 2) The input is <code class="computeroutput"><span class="string">"2 3"</span></code>
        and the stack of parsers looks the same, except the active parser is the
        second <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code> from <code class="computeroutput"><span class="identifier">int_pair</span></code>.
        This parser consumes <code class="computeroutput"><span class="string">"2"</span></code>
        and then <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span></code> skips the subsequent space. Since we've
        finished with <code class="computeroutput"><span class="identifier">int_pair</span></code>'s
        match, its <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span>
        <span class="keyword">int</span><span class="special">&gt;</span></code>
        attribute is complete. It's parent is <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>, so this tuple attribute is pushed
        onto the back of <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>'s
        attribute, which is a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;&gt;</span></code>. Control passes up to the parent
        if <code class="computeroutput"><span class="identifier">int_pair</span></code>, <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>.
        Since <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>
        is a one-or-more parser, it starts a new iteration; control passes to <code class="computeroutput"><span class="identifier">int_pair</span></code> again.
      </p>
<p>
        Step 3) The input is <code class="computeroutput"><span class="string">"3"</span></code>
        and the stack of parsers looks the same, except the active parser is the
        first <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code> from <code class="computeroutput"><span class="identifier">int_pair</span></code>
        again, and we're in the second iteration of <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>. This parser consumes <code class="computeroutput"><span class="string">"3"</span></code>. Since this is the end of the
        input, the second <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code> of <code class="computeroutput"><span class="identifier">int_pair</span></code>
        does not match. This partial match of <code class="computeroutput"><span class="string">"3"</span></code>
        should not count, since it was not part of a full match. So, <code class="computeroutput"><span class="identifier">int_pair</span></code> indicates its failure, and <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code>
        stops iterating. Since it did match once, <code class="computeroutput"><span class="special">+</span><span class="identifier">int_pair</span></code> does not fail; it is a zero-or-more
        parser; failure of its subparser after the first success does not cause it
        to fail. Control passes to the next parser in sequence within <code class="computeroutput"><span class="identifier">int_pairs_plus</span></code>.
      </p>
<p>
        Step 4) The input is <code class="computeroutput"><span class="string">"3"</span></code>
        again, and the stack of parsers is <code class="computeroutput"><span class="identifier">int_pairs_plus</span></code>
        -&gt; <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code>. This parses the <code class="computeroutput"><span class="string">"3"</span></code>,
        and the parse reaches the end of input. Control passes to <code class="computeroutput"><span class="identifier">int_pairs_plus</span></code>,
        which has just successfully matched with all parser in its sequence. It then
        produces its attribute, a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;&gt;,</span> <span class="keyword">int</span><span class="special">&gt;</span></code>, which gets returned from <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">()</span></code>.
      </p>
<p>
        Something to take note of between Steps #3 and #4: at the beginning of #4,
        the input position had returned to where is was at the beginning of #3. This
        kind of backtracking happens in alternative parsers when an alternative fails.
        The next page has more details on the semantics of backtracking.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.parsing_in_detail.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.parsing_in_detail.parsers_in_detail"></a></span><a class="link" href="parsing_in_detail.html#boost_parser__proposed_.tutorial.parsing_in_detail.parsers_in_detail">Parsers
        in detail</a>
      </h5>
<p>
        So far, parsers have been presented as somewhat abstract entities. You may
        be wanting more detail. A Boost.Parser parser <code class="computeroutput"><span class="identifier">P</span></code>
        is an invocable object with a pair of call operator overloads. The two functions
        are very similar, and in many parsers one is implemented in terms of the
        other. The first function does the parsing and returns the default attribute
        for the parser. The second function does exactly the same parsing, but takes
        an out-param into which it writes the attribute for the parser. The out-param
        does not need to be the same type as the default attribute, but they need
        to be compatible.
      </p>
<p>
        Compatibility means that the default attribute is assignable to the out-param
        in some fashion. This usually means direct assignment, but it may also mean
        a tuple -&gt; aggregate or aggregate -&gt; tuple conversion. For sequence
        types, compatibility means that the sequence type has <code class="computeroutput"><span class="identifier">insert</span></code>
        or <code class="computeroutput"><span class="identifier">push_back</span></code> with the usual
        semantics. This means that the parser <code class="computeroutput"><span class="special">+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">::</span><span class="identifier">int_</span></code> can fill a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> just
        as well as a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>.
      </p>
<p>
        Some parsers also have additional state that is required to perform a match.
        For instance, <code class="computeroutput"><span class="identifier">char_</span></code> parsers
        can be parameterized with a single code point to match; the exact value of
        that code point is stored in the parser object.
      </p>
<p>
        No parser has direct support for all the operations defined on parsers (<code class="computeroutput"><span class="keyword">operator</span><span class="special">|</span></code>,
        <code class="computeroutput"><span class="keyword">operator</span><span class="special">&gt;&gt;</span></code>,
        etc.). Instead, there is a template called <code class="computeroutput"><a class="link" href="../../boost/parser/parser_interface.html" title="Struct template parser_interface">parser_interface</a></code> that supports
        all of these operations. <code class="computeroutput"><a class="link" href="../../boost/parser/parser_interface.html" title="Struct template parser_interface">parser_interface</a></code> wraps each
        parser, storing it as a data member, adapting it for general use. You should
        only ever see <code class="computeroutput"><a class="link" href="../../boost/parser/parser_interface.html" title="Struct template parser_interface">parser_interface</a></code> in the debugger,
        or possibly in some of the reference documentation. You should never have
        to write it in your own code.
      </p>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="parsing__struct_s.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="backtracking.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
