<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The Parsers And Their Uses</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="alternative_parsers.html" title="Alternative Parsers">
<link rel="next" href="directives.html" title="Directives">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="alternative_parsers.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="directives.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.the_parsers_and_their_uses"></a><a class="link" href="the_parsers_and_their_uses.html" title="The Parsers And Their Uses">The
      Parsers And Their Uses</a>
</h3></div></div></div>
<p>
        Boost.Parser comes with all the parsers most parsing tasks will ever need.
        Each one is a <code class="computeroutput"><span class="keyword">constexpr</span></code> object,
        or a <code class="computeroutput"><span class="keyword">constexpr</span></code> function. Some
        of the non-functions are also callable, such as <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, which may be used directly,
        or with arguments, as in <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code><code class="computeroutput"><span class="special">(</span><span class="char">'a'</span><span class="special">,</span> <span class="char">'z'</span><span class="special">)</span></code>. Any parser that can be called, whether
        a function or callable object, will be called a <span class="emphasis"><em>callable parser</em></span>
        from now on. Note that there are no nullary callable parsers; they each take
        one or more arguments.
      </p>
<p>
        Each callable parser takes one or more <span class="emphasis"><em>parse arguments</em></span>.
        A parse argument may be a value or an invocable object that accepts a reference
        to the parse context. The reference parameter may be mutable or constant.
        For example:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">get_attribute</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Context</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        This can also be a lambda. For example:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span> <span class="special">}</span>
</pre>
<p>
        The operation that produces a value from a parse argument, which may be a
        value or a callable taking a parse context argument, is referred to as <span class="emphasis"><em>resolving</em></span>
        the parse argument.
      </p>
<p>
        Some callable parsers take a <span class="emphasis"><em>parse predicate</em></span>. A parse
        predicate is not quite the same as a parse argument, because it must be a
        callable object, and cannot be a value. A parse predicate's return type must
        be contextually convertible to <code class="computeroutput"><span class="keyword">bool</span></code>.
        For example:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">equals_three</span>
<span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">==</span> <span class="number">3</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        This may of course be a lambda:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">==</span> <span class="number">3</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
        An example of how parse arguments are used:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="comment">// This parser matches one code point that is at least 'a', and at most</span>
<span class="comment">// the value of last_char, which comes from the globals.</span>
<span class="keyword">auto</span> <span class="identifier">last_char</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">last_char</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">auto</span> <span class="identifier">subparser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">char_</span><span class="special">(</span><span class="char">'a'</span><span class="special">,</span> <span class="identifier">last_char</span><span class="special">);</span>
</pre>
<p>
        Don't worry for now about what the globals are for now; the take-away is
        that you can make any argument you pass to a parser depend on the current
        state of the parse, by using the parse context:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="comment">// This parser parses two code points.  For the parse to succeed, the</span>
<span class="comment">// second one must be &gt;= 'a' and &lt;= the first one.</span>
<span class="keyword">auto</span> <span class="identifier">set_last_char</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">last_char</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">parser</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">char_</span><span class="special">[</span><span class="identifier">set_last_char</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="identifier">subparser</span><span class="special">;</span>
</pre>
<p>
        Each callable parser returns a new parser, parameterized using the arguments
        given in the invocation.
      </p>
<p>
        This table lists all the Boost.Parser parsers. For the callable parsers,
        a separate entry exists for each possible arity of arguments. For a parser
        <code class="computeroutput"><span class="identifier">p</span></code>, if there is no entry for
        <code class="computeroutput"><span class="identifier">p</span></code> without arguments, <code class="computeroutput"><span class="identifier">p</span></code> is a function, and cannot itself be used
        as a parser; it must be called. In the table below:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            each entry is a global object usable directly in your parsers, unless
            otherwise noted;
          </li>
<li class="listitem">
            "code point" is used to refer to the elements of the input
            range, which assumes that the parse is being done in the Unicode-aware
            code path (if the parse is being done in the non-Unicode code path, read
            "code point" as "<code class="computeroutput"><span class="keyword">char</span></code>");
          </li>
<li class="listitem">
            <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><code class="computeroutput"><span class="special">()</span></code>
            is a notional macro that expands to the resolution of parse argument
            or evaluation of a parse predicate;
          </li>
<li class="listitem">
            "<code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">true</span></code>"
            is a shorthand notation for "<code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span></code> is contextually convertible to <code class="computeroutput"><span class="keyword">bool</span></code> and <code class="computeroutput"><span class="keyword">true</span></code>";
            likewise for <code class="computeroutput"><span class="keyword">false</span></code>;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">c</span></code> is a character of type
            <code class="computeroutput"><span class="keyword">char</span></code>, <code class="computeroutput"><span class="identifier">char8_t</span></code>,
            or <code class="computeroutput"><span class="keyword">char32_t</span></code>;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">str</span></code> is a string literal
            of type <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span><span class="special">[]</span></code>, <code class="computeroutput"><span class="identifier">char8_t</span>
            <span class="keyword">const</span> <span class="special">[]</span></code>,
            or <code class="computeroutput"><span class="keyword">char32_t</span> <span class="keyword">const</span>
            <span class="special">[]</span></code>;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">pred</span></code> is a parse predicate;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">arg0</span></code>, <code class="computeroutput"><span class="identifier">arg1</span></code>,
            <code class="computeroutput"><span class="identifier">arg2</span></code>, ... are parse arguments;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">a</span></code> is a semantic action;
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">r</span></code> is an object whose
            type models <code class="computeroutput"><span class="identifier">parsable_range_like</span></code>;
            and
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">p</span></code>, <code class="computeroutput"><span class="identifier">p1</span></code>,
            <code class="computeroutput"><span class="identifier">p2</span></code>, ... are parsers.
          </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          The definition of <code class="computeroutput"><span class="identifier">parsable_range_like</span></code>
          is:
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">concept</span> <span class="identifier">parsable_range</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ranges</span><span class="special">::</span><span class="identifier">forward_range</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span>
    <span class="identifier">parsable_code_unit</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ranges</span><span class="special">::</span><span class="identifier">range_value_t</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">concept</span> <span class="identifier">parsable_pointer</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">is_pointer_v</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">remove_cvref_t</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;</span> <span class="special">&amp;&amp;</span>
    <span class="identifier">parsable_code_unit</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">remove_pointer_t</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">remove_cvref_t</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;&gt;;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">concept</span> <span class="identifier">parsable_range_like</span> <span class="special">=</span> <span class="identifier">parsable_range</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">||</span> <span class="identifier">parsable_pointer</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;;</span>
</pre>
<p>
        </p>
<p>
          It is intended to be a range-like thing; a null-terminated sequence of
          characters is considered range-like, given that a pointer <code class="computeroutput"><span class="identifier">T</span> <span class="special">*</span></code> to
          a null-terminated string is isomorphic with <code class="computeroutput"><span class="identifier">subrange</span><span class="special">&lt;</span><span class="identifier">T</span> <span class="special">*,</span> <a class="link" href="../../boost/parser/null_sentinel_t.html" title="Type definition null_sentinel_t">null_sentinel_t</a><span class="special">&gt;</span></code>.
        </p>
</td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          A slightly more complete description of the attributes generated by these
          parsers is in a subsequent section. The attributes are repeated here so
          you can use see all the properties of the parsers in one place.
        </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Some of the parsers in this table consume no input. All parsers consume
          the input they match unless otherwise stated in the table below.
        </p></td></tr>
</table></div>
<div class="table">
<a name="boost_parser__proposed_.tutorial.the_parsers_and_their_uses.t0"></a><p class="title"><b>Table 1.1. Parsers and Their Semantics</b></p>
<div class="table-contents"><table class="table" summary="Parsers and Their Semantics">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Parser
                </p>
              </th>
<th>
                <p>
                  Semantics
                </p>
              </th>
<th>
                <p>
                  Attribute Type
                </p>
              </th>
<th>
                <p>
                  Notes
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches <span class="emphasis"><em>epsilon</em></span>, the empty string. Always
                  matches, and consumes no input.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  Matching <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  an unlimited number of times creates an infinite loop, which is
                  undefined behavior in C++. Boost.Parser will assert in debug mode
                  when it encounters <code class="computeroutput"><span class="special">*</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>,
                  <code class="computeroutput"><span class="special">+</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>, etc
                  (this applies to unconditional <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code> only).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Fails to match the input if <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span> <span class="special">==</span> <span class="keyword">false</span></code>. Otherwise, the semantics
                  are those of <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ws.html" title="Global ws">ws</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single whitespace code point (see note), according to
                  the Unicode White_Space property.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  For more info, see the <a href="https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt" target="_top">Unicode
                  properties</a>. <code class="computeroutput"><a class="link" href="../../boost/parser/ws.html" title="Global ws">ws</a></code> may consume one
                  code point or two. It only consumes two code points when it matches
                  <code class="computeroutput"><span class="string">"\r\n"</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eol.html" title="Global eol">eol</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single newline (see note), following the "hard"
                  line breaks in the Unicode line breaking algorithm.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  For more info, see the <a href="https://unicode.org/reports/tr14" target="_top">Unicode
                  Line Breaking Algorithm</a>. <code class="computeroutput"><a class="link" href="../../boost/parser/eol.html" title="Global eol">eol</a></code> may consume
                  one code point or two. It only consumes two code points when it
                  matches <code class="computeroutput"><span class="string">"\r\n"</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eoi.html" title="Global eoi">eoi</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches only at the end of input, and consumes no input.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/attr.html" title="Function template attr">attr</a></code><code class="computeroutput"><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Always matches, and consumes no input. Generates the attribute
                  <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">))</span></code>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches any single code point.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the code point <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches the next code point <code class="computeroutput"><span class="identifier">n</span></code>
                  in the input, if <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span> <span class="special">&lt;=</span>
                  <span class="identifier">n</span> <span class="special">&amp;&amp;</span>
                  <span class="identifier">n</span> <span class="special">&lt;=</span>
                  <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches the next code point <code class="computeroutput"><span class="identifier">n</span></code>
                  in the input, if <code class="computeroutput"><span class="identifier">n</span></code>
                  is one of the code points in <code class="computeroutput"><span class="identifier">r</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See <a class="link" href="attribute_generation.html" title="Attribute Generation">Attribute
                  Generation</a>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">r</span></code> is taken to be
                  in a UTF encoding. The exact UTF used depends on <code class="computeroutput"><span class="identifier">r</span></code>'s element type. If you do not
                  pass UTF encoded ranges for <code class="computeroutput"><span class="identifier">r</span></code>,
                  the behavior of <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code> is undefined.
                  Note that ASCII is a subset of UTF-8, so ASCII is fine. EBCDIC
                  is not. <code class="computeroutput"><span class="identifier">r</span></code> is not
                  copied; a reference to it is taken. The lifetime of <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code> must be within the lifetime of
                  <code class="computeroutput"><span class="identifier">r</span></code>. This overload
                  of <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>
                  does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/cp.html" title="Global cp">cp</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">char32_t</span></code>
                </p>
              </td>
<td>
                <p>
                  Similar to <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, but with
                  a fixed <code class="computeroutput"><span class="keyword">char32_t</span></code> attribute
                  type; <code class="computeroutput"><a class="link" href="../../boost/parser/cp.html" title="Global cp">cp</a></code>
                  has all the same call operator overloads as <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, though they
                  are not repeated here, for brevity.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/cu.html" title="Global cu">cu</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">char</span></code>
                </p>
              </td>
<td>
                <p>
                  Similar to <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, but with
                  a fixed <code class="computeroutput"><span class="keyword">char</span></code> attribute
                  type; <code class="computeroutput"><a class="link" href="../../boost/parser/cu.html" title="Global cu">cu</a></code>
                  has all the same call operator overloads as <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>, though they
                  are not repeated here, for brevity. Even though the name "<code class="computeroutput"><span class="identifier">cu</span></code>" suggests that this parser
                  match at the code unit level, it does not. The name refers to the
                  attribute type generated, much like the names <code class="computeroutput"><a class="link" href="../../boost/parser/int_.html" title="Global int_">int_</a></code> versus <code class="computeroutput"><a class="link" href="../../boost/parser/uint_.html" title="Global uint_">uint_</a></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/alnum.html" title="Global alnum">ascii::alnum</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">alnum</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/alpha.html" title="Global alpha">ascii::alpha</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isalpha</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/blank.html" title="Global blank">ascii::blank</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isblank</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/cntrl.html" title="Global cntrl">ascii::cntrl</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">iscntrl</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/digit.html" title="Global digit">ascii::digit</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isdigit</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/graph.html" title="Global graph">ascii::graph</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isgraph</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/print.html" title="Global print">ascii::print</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isprint</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/punct.html" title="Global punct">ascii::punct</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ispunct</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/space.html" title="Global space">ascii::space</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isspace</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/xdigit.html" title="Global xdigit">ascii::xdigit</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isxdigit</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/lower.html" title="Global lower">ascii::lower</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">islower</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ascii/upper.html" title="Global upper">ascii::upper</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a single code point for which <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">isupper</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">true</span></code>.
                </p>
              </td>
<td>
                <p>
                  The code point type in Unicode parsing, or <code class="computeroutput"><span class="keyword">char</span></code>
                  in non-Unicode parsing. See the entry for <code class="computeroutput"><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code>.
                </p>
              </td>
<td>
                <p>
                  Intended for parsing of ASCII only. The results will be wrong for
                  many, many cases if used for Unicode parsing.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_idm19744.html" title="Function lit">lit</a></code><code class="computeroutput"><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given code point <code class="computeroutput"><span class="identifier">c</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_idm19744.html" title="Function lit">lit()</a></code> does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">c_l</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given code point <code class="computeroutput"><span class="identifier">c</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  This is a <a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_top">UDL</a>
                  that represents <code class="computeroutput"><a class="link" href="../../boost/parser/lit_idm19744.html" title="Function lit">lit</a><span class="special">(</span><span class="identifier">c</span><span class="special">)</span></code>,
                  for example <code class="computeroutput"><span class="char">'F'</span><span class="identifier">_l</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_idm19744.html" title="Function lit">lit</a></code><code class="computeroutput"><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given string <code class="computeroutput"><span class="identifier">r</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/lit_idm19744.html" title="Function lit">lit()</a></code> does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">str_l</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the given string <code class="computeroutput"><span class="identifier">str</span></code>.
                </p>
              </td>
<td>
                <p>
                  None.
                </p>
              </td>
<td>
                <p>
                  This is a <a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_top">UDL</a>
                  that represents <code class="computeroutput"><a class="link" href="../../boost/parser/lit_idm19744.html" title="Function lit">lit</a><span class="special">(</span><span class="identifier">s</span><span class="special">)</span></code>,
                  for example <code class="computeroutput"><span class="string">"a string"</span><span class="identifier">_l</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/string.html" title="Function template string">string</a><span class="special">(</span><span class="identifier">r</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly <code class="computeroutput"><span class="identifier">r</span></code>,
                  and generates the match as an attribute.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/string.html" title="Function template string">string()</a></code> does <span class="bold"><strong>not</strong></span> take parse arguments.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">str_p</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly <code class="computeroutput"><span class="identifier">str</span></code>,
                  and generates the match as an attribute.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
                </p>
              </td>
<td>
                <p>
                  This is a <a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_top">UDL</a>
                  that represents <code class="computeroutput"><a class="link" href="../../boost/parser/string.html" title="Function template string">string</a><span class="special">(</span><span class="identifier">s</span><span class="special">)</span></code>, for example <code class="computeroutput"><span class="string">"a
                  string"</span><span class="identifier">_p</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/bool_.html" title="Global bool_">bool_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches <code class="computeroutput"><span class="string">"true"</span></code>
                  or <code class="computeroutput"><span class="string">"false"</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/bin.html" title="Global bin">bin</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a binary unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
                <p>
                  For example, <code class="computeroutput"><a class="link" href="../../boost/parser/bin.html" title="Global bin">bin</a></code> would match
                  <code class="computeroutput"><span class="string">"101"</span></code>, and
                  generate an attribute of <code class="computeroutput"><span class="number">5u</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/bin.html" title="Global bin">bin</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the binary unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/oct.html" title="Global oct">oct</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an octal unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
                <p>
                  For example, <code class="computeroutput"><a class="link" href="../../boost/parser/oct.html" title="Global oct">oct</a></code> would match
                  <code class="computeroutput"><span class="string">"31"</span></code>, and
                  generate an attribute of <code class="computeroutput"><span class="number">25u</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/oct.html" title="Global oct">oct</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the octal unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/hex.html" title="Global hex">hex</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a hexadecimal unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
                <p>
                  For example, <code class="computeroutput"><a class="link" href="../../boost/parser/hex.html" title="Global hex">hex</a></code> would match
                  <code class="computeroutput"><span class="string">"ff"</span></code>, and
                  generate an attribute of <code class="computeroutput"><span class="number">255u</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/hex.html" title="Global hex">hex</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the hexadecimal unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ushort_.html" title="Global ushort_">ushort_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ushort_.html" title="Global ushort_">ushort_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/uint_.html" title="Global uint_">uint_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/uint_.html" title="Global uint_">uint_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_.html" title="Global ulong_">ulong_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_.html" title="Global ulong_">ulong_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_long.html" title="Global ulong_long">ulong_long</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches an unsigned integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span>
                  <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/ulong_long.html" title="Global ulong_long">ulong_long</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the unsigned integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">long</span>
                  <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/short_.html" title="Global short_">short_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/short_.html" title="Global short_">short_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">short</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/int_.html" title="Global int_">int_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/int_.html" title="Global int_">int_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">int</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_.html" title="Global long_">long_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_.html" title="Global long_">long_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_long.html" title="Global long_long">long_long</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a signed integral value.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/long_long.html" title="Global long_long">long_long</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches exactly the signed integral value <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/float_.html" title="Global float_">float_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a floating-point number. <code class="computeroutput"><a class="link" href="../../boost/parser/float_.html" title="Global float_">float_</a></code> uses parsing
                  implementation details from <a href="https://www.boost.org/doc/libs/release/libs/spirit" target="_top">Boost.Spirit</a>.
                  The specifics of what formats are accepted can be found in their
                  <a href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/numeric/real.html" target="_top">real
                  number parsers</a>. Note that only the default <code class="computeroutput"><span class="identifier">RealPolicies</span></code> is supported by
                  <code class="computeroutput"><a class="link" href="../../boost/parser/float_.html" title="Global float_">float_</a></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">float</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/double_.html" title="Global double_">double_</a></code>
                </p>
              </td>
<td>
                <p>
                  Matches a floating-point number. <code class="computeroutput"><a class="link" href="../../boost/parser/double_.html" title="Global double_">double_</a></code> uses parsing
                  implementation details from <a href="https://www.boost.org/doc/libs/release/libs/spirit" target="_top">Boost.Spirit</a>.
                  The specifics of what formats are accepted can be found in their
                  <a href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/numeric/real.html" target="_top">real
                  number parsers</a>. Note that only the default <code class="computeroutput"><span class="identifier">RealPolicies</span></code> is supported by
                  <code class="computeroutput"><a class="link" href="../../boost/parser/double_.html" title="Global double_">double_</a></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="keyword">double</span></code>
                </p>
              </td>
<td>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_idm19693.html" title="Function template repeat">repeat</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)[</span><span class="identifier">p</span><span class="special">]</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches iff <code class="computeroutput"><span class="identifier">p</span></code> matches
                  exactly <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code> times.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  The special value <code class="computeroutput"><a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a></code> may be used;
                  it indicates unlimited repetition. <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">))</span></code> must be implicitly convertible
                  to <code class="computeroutput"><span class="identifier">int64_t</span></code>. Matching
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  an unlimited number of times creates an infinite loop, which is
                  undefined behavior in C++. Boost.Parser will assert in debug mode
                  when it encounters <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_idm19693.html" title="Function template repeat">repeat</a><span class="special">(</span><a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a><span class="special">)[</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">]</span></code> (this applies to unconditional
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  only).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_idm19693.html" title="Function template repeat">repeat</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)[</span><span class="identifier">p</span><span class="special">]</span></code>
                </p>
              </td>
<td>
                <p>
                  Matches iff <code class="computeroutput"><span class="identifier">p</span></code> matches
                  between <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code> and <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span></code> times, inclusively.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  The special value <code class="computeroutput"><a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a></code> may be used
                  for the upper bound; it indicates unlimited repetition. <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">))</span></code> and <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">))</span></code> each must be implicitly convertible
                  to <code class="computeroutput"><span class="identifier">int64_t</span></code>. Matching
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  an unlimited number of times creates an infinite loop, which is
                  undefined behavior in C++. Boost.Parser will assert in debug mode
                  when it encounters <code class="computeroutput"><a class="link" href="../../boost/parser/repeat_idm19693.html" title="Function template repeat">repeat</a><span class="special">(</span><span class="identifier">n</span><span class="special">,</span> <a class="link" href="../../boost/parser/Inf.html" title="Global Inf">Inf</a><span class="special">)[</span><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">]</span></code> (this applies to unconditional
                  <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
                  only).
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/if_.html" title="Function template if_">if_</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)[</span><span class="identifier">p</span><span class="special">]</span></code>
                </p>
              </td>
<td>
                <p>
                  Equivalent to <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span>
                  <span class="special">&gt;&gt;</span> <span class="identifier">p</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p</span><span class="special">)&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  It is an error to write <code class="computeroutput"><a class="link" href="../../boost/parser/if_.html" title="Function template if_">if_</a><span class="special">(</span><span class="identifier">pred</span><span class="special">)</span></code>.
                  That is, it is an error to omit the conditionally matched parser
                  <code class="computeroutput"><span class="identifier">p</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/switch_.html" title="Function template switch_">switch_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">p1</span><span class="special">)(</span><span class="identifier">arg2</span><span class="special">,</span> <span class="identifier">p2</span><span class="special">)</span> <span class="special">...</span></code>
                </p>
              </td>
<td>
                <p>
                  Equivalent to <code class="computeroutput"><span class="identifier">p1</span></code>
                  when <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span> <span class="special">==</span> <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span></code>, <code class="computeroutput"><span class="identifier">p2</span></code>
                  when <code class="computeroutput"><span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span> <span class="special">==</span> <span class="emphasis"><em><code class="literal">RESOLVE</code></em></span><span class="special">(</span><span class="identifier">arg2</span><span class="special">)</span></code>, etc. If there is such no <code class="computeroutput"><span class="identifier">argN</span></code>, the behavior of <code class="computeroutput"><a class="link" href="../../boost/parser/switch_.html" title="Function template switch_">switch_()</a></code> is undefined.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p1</span><span class="special">),</span> <span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">p2</span><span class="special">),</span> <span class="special">...&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  It is an error to write <code class="computeroutput"><a class="link" href="../../boost/parser/switch_.html" title="Function template switch_">switch_</a><span class="special">(</span><span class="identifier">arg0</span><span class="special">)</span></code>. That is, it is an error to omit
                  the conditionally matched parsers <code class="computeroutput"><span class="identifier">p1</span></code>,
                  <code class="computeroutput"><span class="identifier">p2</span></code>, ....
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols&lt;T&gt;</a></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols</a></code>
                  is an associative container of key, value pairs. Each key is a
                  <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> and each value has type
                  <code class="computeroutput"><span class="identifier">T</span></code>. In the Unicode
                  parsing path, the strings are considered to be UTF-8 encoded; in
                  the non-Unicode path, no encoding is assumed. <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols</a></code> Matches the
                  longest prefix <code class="computeroutput"><span class="identifier">pre</span></code>
                  of the input that is equal to one of the keys <code class="computeroutput"><span class="identifier">k</span></code>.
                  If the length <code class="computeroutput"><span class="identifier">len</span></code>
                  of <code class="computeroutput"><span class="identifier">pre</span></code> is zero,
                  and there is no zero-length key, it does not match the input. If
                  <code class="computeroutput"><span class="identifier">len</span></code> is positive,
                  the generated attribute is the value associated with <code class="computeroutput"><span class="identifier">k</span></code>.
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">T</span></code>
                </p>
              </td>
<td>
                <p>
                  Unlike the other entries in this table, <code class="computeroutput"><a class="link" href="../../boost/parser/symbols.html" title="Struct template symbols">symbols</a></code> is a type,
                  not an object.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
        If you have an integral type <code class="computeroutput"><span class="identifier">IntType</span></code>
        that is not covered by any of the Boost.Parser parsers, you can use a more
        verbose declaration to declare a parser for <code class="computeroutput"><span class="identifier">IntType</span></code>.
        If <code class="computeroutput"><span class="identifier">IntType</span></code> were unsigned,
        you would use <code class="computeroutput"><span class="identifier">uint_parser</span></code>.
        If it were signed, you would use <code class="computeroutput"><span class="identifier">int_parser</span></code>.
        For example:
      </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="identifier">parser_interface</span><span class="special">&lt;</span><span class="identifier">int_parser</span><span class="special">&lt;</span><span class="identifier">IntType</span><span class="special">&gt;&gt;</span> <span class="identifier">hex_int</span><span class="special">;</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">uint_parser</span></code> and <code class="computeroutput"><span class="identifier">int_parser</span></code> accept three more non-type template
        parameters after the type parameter. They are <code class="computeroutput"><span class="identifier">Radix</span></code>,
        <code class="computeroutput"><span class="identifier">MinDigits</span></code>, and <code class="computeroutput"><span class="identifier">MaxDigits</span></code>. <code class="computeroutput"><span class="identifier">Radix</span></code>
        defaults to <code class="computeroutput"><span class="number">10</span></code>, <code class="computeroutput"><span class="identifier">MinDigits</span></code> to <code class="computeroutput"><span class="number">1</span></code>,
        and <code class="computeroutput"><span class="identifier">MaxDigits</span></code> to <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>, which is
        a sentinel value meaning that there is no max number of digits.
      </p>
<p>
        So, if you wanted to parse exactly eight hexadecimal digits in a row in order
        to recognize Unicode character literals like C++ has (e.g. <code class="computeroutput"><span class="special">\</span><span class="identifier">Udeadbeef</span></code>),
        you could use this parser for the digits at the end:
      </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="identifier">parser_interface</span><span class="special">&lt;</span><span class="identifier">uint_parser</span><span class="special">&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">,</span> <span class="number">16</span><span class="special">,</span> <span class="number">8</span><span class="special">,</span> <span class="number">8</span><span class="special">&gt;&gt;</span> <span class="identifier">hex_int</span><span class="special">;</span>
</pre>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="alternative_parsers.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="directives.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
