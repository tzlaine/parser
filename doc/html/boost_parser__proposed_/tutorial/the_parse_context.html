<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The Parse Context</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="parsing_to_find_subranges.html" title="Parsing to Find Subranges">
<link rel="next" href="rule_parsers.html" title="Rule Parsers">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="parsing_to_find_subranges.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="rule_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.the_parse_context"></a><a class="link" href="the_parse_context.html" title="The Parse Context">The
      Parse Context</a>
</h3></div></div></div>
<p>
        Now would be a good time to describe the parse context in some detail. Any
        semantic action that you write will need to use state in the parse context,
        so you need to know what's available.
      </p>
<p>
        The parse context is an object that stores the current state of the parse
        — the current- and end-iterators, the error handler, etc. Data may
        seem to be "added" to or "removed" from it at different
        times during the parse. For instance, when a parser <code class="computeroutput"><span class="identifier">p</span></code>
        with a semantic action <code class="computeroutput"><span class="identifier">a</span></code>
        succeeds, the context adds the attribute that <code class="computeroutput"><span class="identifier">p</span></code>
        produces to the parse context, then calls <code class="computeroutput"><span class="identifier">a</span></code>,
        passing it the context.
      </p>
<p>
        Though the context object appears to have things added to or removed from
        it, it does not. In reality, there is no one context object. Contexts are
        formed at various times during the parse, usually when starting a subparser.
        Each context is formed by taking the previous context and adding or changing
        members as needed to form a new context object. When the function containing
        the new context object returns, its context object (if any) is destructed.
        This is efficient to do, because the parse context has only about a dozen
        data members, and each data member is less than or equal to the size of a
        pointer. Copying the entire context when mutating the context is therefore
        fast. The context does no memory allocation.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          All these functions that take the parse context as their first parameter
          will find by found by Argument-Dependent Lookup. You will probably never
          need to qualify them with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">::</span></code>.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_always_available"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_always_available">Accessors
        for data that are always available</a>
      </h5>
<p>
        By convention, the names of all Boost.Parser functions that take a parse
        context, and are therefore intended for use inside semantic actions, contain
        a leading underscore.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___pass___code__phrase_role__identifier___pass__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___pass___code__phrase_role__identifier___pass__phrase__phrase_role__special______phrase___code___functionname_">_pass()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_pass.html" title="Function template _pass">_pass()</a></code> returns a reference to a
        <code class="computeroutput"><span class="keyword">bool</span></code> indicating the success
        of failure of the current parse. This can be used to force the current parse
        to pass or fail:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// If the attribute fails to meet this predicate, fail the parse.</span>
    <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">necessary_condition</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)))</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Note that for a semantic action to be executed, its associated parser must
        already have succeeded. So unless you previously wrote <code class="computeroutput"><span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span>
        <span class="special">=</span> <span class="keyword">false</span></code>
        within your action, <code class="computeroutput"><span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span>
        <span class="special">=</span> <span class="keyword">true</span></code>
        does nothing; it's redundant.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h2"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___begin___code__phrase_role__identifier___begin__phrase__phrase_role__special______phrase___code___functionname____functionname_alt__boost__parser___end___code__phrase_role__identifier___end__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___where___code__phrase_role__identifier___where__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___begin___code__phrase_role__identifier___begin__phrase__phrase_role__special______phrase___code___functionname____functionname_alt__boost__parser___end___code__phrase_role__identifier___end__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___where___code__phrase_role__identifier___where__phrase__phrase_role__special______phrase___code___functionname_">_begin(), _end()
        and _where()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_begin.html" title="Function template _begin">_begin()</a></code> and <code class="computeroutput"><a class="link" href="../../boost/parser/_end.html" title="Function template _end">_end()</a></code>
        return the beginning and end of the range that you passed to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm26171.html" title="Function template parse">parse()</a></code>, respectively. <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where()</a></code> returns a <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code> indicating the bounds
        of the input matched by the current parse. <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where()</a></code>
        can be useful if you just want to parse some text and return a result consisting
        of where certain elements are located, without producing any other attributes.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h3"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___error_handler___code__phrase_role__identifier___error_handler__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___error_handler___code__phrase_role__identifier___error_handler__phrase__phrase_role__special______phrase___code___functionname_">_error_handler()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_error_handler.html" title="Function template _error_handler">_error_handler()</a></code> returns a reference to the
        error handler associated with the parser passed to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm26171.html" title="Function template parse">parse()</a></code>.
        See <a class="link" href="error_handling_and_debugging.html" title="Error Handling and Debugging">Error
        Handling and Debugging</a> for more information on what you can do with
        the error handler.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h4"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_only_sometimes_available"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_only_sometimes_available">Accessors
        for data that are only sometimes available</a>
      </h5>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h5"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___attr___code__phrase_role__identifier___attr__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___attr___code__phrase_role__identifier___attr__phrase__phrase_role__special______phrase___code___functionname_">_attr()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_attr.html" title="Function template _attr">_attr()</a></code> returns a reference to the
        value of the current parser's attribute. It is available only when the current
        parser's parse is successful. If the parser has no semantic action, no attribute
        gets added to the parse context. It can be used to read and write the current
        parser's attribute:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="number">3</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
        If the current parser has no attribute, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code> is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h6"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_">_val()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function template _val">_val()</a></code> returns a reference to the
        value of the attribute of the current rule being used to parse (if any),
        and is available even before the rule's parse is successful. It can be used
        to set the current rule's attribute, even from a parser that is a subparser
        inside the rule. Let's say we're writing a parser with a semantic action
        that is within a rule. If we want to set the current rule's value to whatever
        this subparser parses, we would write this semantic action:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span> <span class="special">}</span>
</pre>
<p>
        If there is no current rule, or the current rule has no attribute, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h7"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___globals___code__phrase_role__identifier___globals__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___globals___code__phrase_role__identifier___globals__phrase__phrase_role__special______phrase___code___functionname_">_globals()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code> returns a reference to a
        user-supplied struct that contains whatever data you want to use during the
        parse. We'll get into this more later, but for now, here's how you might
        use it:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// black_list is some set of values that are not allowed.</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">black_list</span><span class="special">.</span><span class="identifier">contains</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)))</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h8"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___locals___code__phrase_role__identifier___locals__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___locals___code__phrase_role__identifier___locals__phrase__phrase_role__special______phrase___code___functionname_">_locals()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code> returns a reference to one
        or more values that are local to the current rule being parsed, if any. If
        there are two or more local values, <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>
        returns a reference to a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a></code>. Rules with locals are
        something we haven't gotten to yet, but here is how you use <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">local</span> <span class="special">=</span> <span class="identifier">_locals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span>
    <span class="comment">// Use local here.  If boost::parser::tuple aliases to hana::tuple, access</span>
    <span class="comment">// its members like this:</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">hana</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">first_element</span> <span class="special">=</span> <span class="identifier">local</span><span class="special">[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">];</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">second_element</span> <span class="special">=</span> <span class="identifier">local</span><span class="special">[</span><span class="number">1</span><span class="identifier">_c</span><span class="special">];</span>
<span class="special">}</span>
</pre>
<p>
        If there is no current rule, or the current rule has no locals, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h9"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___params___code__phrase_role__identifier___params__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___params___code__phrase_role__identifier___params__phrase__phrase_role__special______phrase___code___functionname_">_params()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_params.html" title="Function template _params">_params()</a></code>, like <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>,
        applies to the current rule being used to parse, if any. It also returns
        a reference to a single value, if the current rule has only one parameter,
        or a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a></code>
        of multiple values if the current rule has multiple parameters.
      </p>
<p>
        If there is no current rule, or the current rule has no parameters, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
          is a type that is used as a return value in Boost.Parser for parse context
          accessors. <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
          is convertible to anything that has a default constructor, convertible
          from anything, assignable form anything, and has templated overloads for
          all the overloadable operators. The intention is that a misuse of <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function template _val">_val()</a></code>, <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code>,
          etc. should compile, and produce an assertion at runtime. Experience has
          shown that using a debugger for investigating the stack that leads to your
          mistake is a far better user experience than sifting through compiler diagnostics.
          See the <a class="link" href="../rationale.html" title="Rationale">Rationale</a>
          section for a more detailed explanation.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h10"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___no_case___code__phrase_role__identifier___no_case__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___no_case___code__phrase_role__identifier___no_case__phrase__phrase_role__special______phrase___code___functionname_">_no_case()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../header/boost/parser/parser_hpp.html#boost.parser._no_case">_no_case()</a></code> returns <code class="computeroutput"><span class="keyword">true</span></code>
        if the current parse context is inside one or more (possibly nested) <code class="computeroutput"><a class="link" href="../../boost/parser/no_case.html" title="Global no_case">no_case[]</a></code> directives.
      </p>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="parsing_to_find_subranges.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="rule_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
